= {article-title}
{author-name}
{revdate}
// TOC
:toc:
:toclevels: 4

Christmas is coming!
Like every year, Santa needs to schedule its presents delivery.
Can you imagine?
Millions of (good) children will receive a present on the night of the 24th of December.
To achieve this prowess, Santa needs a bit of technical help to schedule the deliveries.

== Resilient Microservice Architecture

Santa has its own microservice (called _Santa_), with its own database, to schedule his coming deliveries.
With this microservice, he can find his past deliveries per country, but more important, he can create the new schedule for Christmas 2020.
For that, Santa accesses two external microservices developed and maintained by external partners:

* _Kid_: Third-party microservice that gives you the list of good kids per country who deserve a present (the naughty ones don't get anything this year).
* _Pokemon_: Third-party microservice returning Pokemons (this year Santa will only deliver Pokemons).

[[javaadvent-figure-architecture]]
.Microservice Architecture
image::javaadvent-figure-architecture.png[]

On the 24th of December, Santa will only have a few hours to deliver Pokemons to all the good children all over the globe.
That means that the _Santa_ microservice will invoke the _Kids_ microservice to get the location of all the good kids, per country, and then, for each kid, it invokes the _Pokemon_ microservice to get a present.
So the system cannot fail!
We need to build a resilient architecture.

If the Santa microservices cannot access the two external microservices (eg. due to network problem because of weather condition), we need to find a backup plan.
As a backup, if Santa cannot access the _Kids_ microservice, he can create his new schedule based on the schedule of the previous year (which is stored in his local database).
And if the _Pokemon_ microservice does not respond, well, Santa will deliver some lollies instead (he has tons of lollies).

For that, we can use _MicroProfile_ with _Quarkus_.

== MicroProfile and Quarkus

_{microprofile-long-name}_ addresses the need for enterprise Java microservices.footnote:[{microprofile-short-name} {microprofile-jsr-url}]
It is a set of specifications for handling microservices design patterns.
MicroProfile APIs establish an optimal foundation for developing microservices-based applications by adopting a subset of the Jakarta EE standards and extending them to address common microservices patterns.
_{microprofile-long-name}_ is specified under the _Eclipse Foundation_ and is implemented by _{microprofile-ref-implementation}_.footnote:[{microprofile-ref-implementation} {microprofile-ref-implementation-url}]

If you haven't heard of Quarkus, you should definitely look at it.
Quarkus is _A Kubernetes Native Java stack tailored for OpenJDK HotSpot & GraalVM, crafted from the best of breed Java libraries and standards_.footnote:[{quarkus-short-name} {quarkus-jsr-url}]
In practice, Quarkus is an Open Source stack for writing Java applications, specifically back end applications.
So Quarkus is not limited to microservices, even though it is highly suited for it.
From a developer's point of view, Quarkus proposes a nice developer experience:
it gives you fast live reload, unified configuration and hides the complexity of GraalVM, allowing you to easily generate native executables.
All this without reinventing the wheel by proposing a new programming model, Quarkus leverages your experience in standard libraries that you already know (e.g. CDI, JPA, Bean Validation, JAX-RS, etc.) as well as many popular frameworks (e.g. Vert.x, Apache Camel, etc.).

To build Santa a resilient system, we will use Quarkus with two MicroProfile specifications:
_{rest-client-long-name}_ and _{fault-tolerance-long-name}_

Let's develop the _Santa REST Endpoint_ with Quarkus and JAX-RS.

== Santa REST Endpoint

To interact with the _Santa_ microservice, we will develop a JAX-RS endpoint called `SantaResource`.

[[javaadvent-figure-santa]]
.Santa Microservice
image::javaadvent-figure-santa.png[]

As shown in the diagram above, the `SantaResource` has two methods:

* `createASchedule()`: Invoked with an HTTP POST, this method creates the schedule for one country.
* `getASchedule()`: Invoked with an HTTP GET, this method returns a schedule for a given country and a given year.

The `createASchedule()` method delegate the business logic and database access to a `SantaService`.
This service is the one invoking the remote third-party microservices _Kid_ and _Pokemon_.
It also accesses the database through the `Schedule` entity.
A schedule is made for a specific year (2020 in our case) and country.
It has a set of deliveries:
a delivery is when Santa delivers one present to one child.

[[javaadvent-listing-santa-rest]]
.Santa REST Endpoint
[source]
----
include::{code-github-raw}/rest-santa/src/main/java/org/agoncal/article/javaadvent/santa/SantaResource.java[tags=adocSnippet;!adocSkip]
----

The way Santa invokes this endpoint is as follow:

[source,term]
----
# Creates a new schedule for Angola
curl -X POST -H "Content-Type: text/plain" -d "Angola" http://localhost:8701/api/santa

# Gets the 2019 schedule for Venezuela
curl "http://localhost:8701/api/santa?country=Venezuela&year=2019"
----

Now let's use _{rest-client-long-name}_ so the `SantaService` can access the remote microservices.

== MicroProfile Rest Client

_{rest-client-long-name}_ provides a type safe approach using proxies and annotations for invoking RESTful services over HTTP.footnote:[{rest-client-short-name} {rest-client-jsr-url}]
The {rest-client-long-name} builds upon the JAX-RS APIs for consistency and ease-of-use.

As seen in the `SantaResource`, the method `createASchedule()` invokes the `getAllGoodChildren()` of the `SantaService`.
`getAllGoodChildren()` uses a `ChildProxy` to communicate with the remote _Kid_ microservice.
For that, we use the standard CDI `@Inject` annotation in conjunction with the MicroProfile `@RestClient` annotation to inject the `ChildProxy` interface:

[[javaadvent-listing-kids-invoc]]
.SantaService Invoking the Kid Microservice Through a Proxy
[source,indent=0]
----
include::{code-github-raw}/rest-santa/src/main/java/org/agoncal/article/javaadvent/santa/SantaService.java[tags=adocSnippet;adocChildProxy;!adocChildProxyFallback;!adocPresentProxy;!adocPresentProxyFallback;!adocSkip]
----

Using the {rest-client-long-name} is as simple as creating a `ChildProxy` interface using the proper JAX-RS and MicroProfile annotations:

* `@RegisterRestClient` allows Quarkus to know that this interface is meant to be available for CDI injection as a REST Client,
* `@Path` and `@GET` are the standard JAX-RS annotations used to define how to access the remote service,
* `@Produces` defines the expected content-type.


[[javaadvent-listing-kids-proxy]]
.Child Proxy
[source]
----
include::{code-github-raw}/rest-santa/src/main/java/org/agoncal/article/javaadvent/santa/proxy/ChildProxy.java[tag=adocSnippet]
----

[[javaadvent-listing-kids-config]]
.Child Proxy Configuration
[source,text]
----
include::{code-github-raw}/rest-santa/src/main/resources/application.properties[tag=adocSnippet]
----


== MicroProfile Fault-Tolerance

As the number of services grows, the odds of any service failing also grows.
If one of the involved services does not respond as expected, e.g. because of fragile network communication, we have to compensate for this exceptional situation.
_{fault-tolerance-long-name}_ allows us to build up our microservice architecture to be resilient and fault tolerant by design.
This means we must not only be able to detect any issue but also to handle it automatically.

== Invoking the Microservice

[[javaadvent-listing-santa]]
.Santa
[source]
----
include::{code-github-raw}/rest-santa/src/main/java/org/agoncal/article/javaadvent/santa/SantaResource.java[]
----

== Falling Back



