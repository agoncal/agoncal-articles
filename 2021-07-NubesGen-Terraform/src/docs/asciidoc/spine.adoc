= How to Manually Deploy a Quarkus Application to Azure with Terraform Thanks to NubesGen
Antonio Goncalves
// TOC
:toc:
:toclevels: 4

In this blog post I'll show you how to manually deploy a simple _Quarkus_ application to _Azure_ using _Terraform_, thanks to _NubesGen_.

//This is the first blog post of a series of three on Quarkus and NubesGen:
//
//* How to Manually Deploy a Quarkus Application to Azure with Terraform Thanks to NubesGen
//* How to Automatically Deploy a Quarkus Application to Azure with GitHub Actions Thanks to NubesGen
//* How to Deploy a JHipster Quarkus Application to Azure Thanks to NubesGen
//
//You can watch this Quarkus Tip that summarises what's covered in this series of blog posts:

== What's Covered in This Blog Post?

To break it into more details, these are the topics that will be covered in this blog post:

* What is _Terraform_?
* What is _NubesGen_?
* Generate a basic _Quarkus_ REST endpoint.
* Package the Quarkus application in an Uber JAR.
* Use NubesGen to generate Terraform templates.
* Use the Azure Maven plugin to deploy the Quarkus application to Azure.
* Check the deployed application on Azure.

=== Use Case

The goal of this blog post is to focus on Terraform, Azure and NubesGen.
So the idea is use Quarkus to develop a very simple REST endpoint that says _hello_ (yet another hello world).
Then we package this REST endpoint into an Uber JAR and deploy it on Azure thanks to Terraform templates and the Azure Maven plugin.

.REST Endpoint Packaged into an Uber JAR
image::2021-07-architecture.png[]

=== Prerequisites

To follow along and be able to execute the code samples, you will need the following tools installed on your machine:

* JDK 11 and Maven (Quarkus also supports Gradle if you pref)
* https://docs.microsoft.com/en-us/cli/azure/install-azure-cli[Azure CLI] (`brew install azure-cli` to install on Mac)
* https://www.terraform.io/docs/cli/commands/index.html[Terraform CLI]  (`brew tap hashicorp/tap & brew install hashicorp/tap/terraform` on Mac)
* https://azure.microsoft.com/en-us/free/[Have an Azure subscription]

== What Is Terraform?

But first, let me introduce https://learn.hashicorp.com/terraform[Terraform].
Terraform is an Open Source tool for provisioning and managing infrastructures.
This can be done on the cloud but also on-premise.

As stated on their website, Terraform is an infrastructure as code (IaC) tool to _"build, change, version and destroy infrastructure safely and efficiently"_.
The idea is to define, with code, what your infrastructure will look like and let Terraform provision this infrastructure.
In a Terraform file, you describe your overall topology (network, security group roles, virtual machines, load balancers, etc) and leave Terraform to create it.
If the topology of your application changes overtime (eg. you add firewalls, DNS, CDN, etc.), Terraform calculates the delta and only creates/destroys/updates what has changed.

These Terraform files are written in https://www.terraform.io/docs/language/index.html[HashiCorp Configuration Language], or HCL, which is human readable and looks like a mixture or JSON and YAML (but it can also be expressed in pure JSON).
The advantage of declaring your infrastructure with code, is that you can easily read it, change it, store it within your code, version it, etc.

=== Terraform Workflow

But Terraform is not only a language.
Terraform also gives us a workflow to creating and managing our infrastructure.

.Terraform Workflow
image::2021-07-terraform-state.png[]

As a resource topology becomes complex, understanding the meaning and impact of infrastructure changes can be difficult.

* refresh: reconciles the way Terraform thinks the infrastructure looks like, with the real world.
It checks with the Cloud provider what's running at the moment, it gets an up to date view of what the infrastructure actually is
* plan: Terraform figures out what it needs to do. Reconciling what's acutally running, with what we want to be running (the disered configuration)
* apply: Terraform actually does the job, and applies the needed changes to go from what's running to the disired state
* destroy: Destroys all the components

=== Terraform Architecture

The strength of Terraform is its ecosystem.
Basically, you can create any kind of resource on most of the Cloud providers or on-premise.
Why?
Because Terraform uses an extension mechanism where you can add as many providers as you need.

In fact, the way Terraform is architectured is with:

* Core: The core is the one dealing with the workflow lifecycle that we just saw.
It takes the configuration files, takes the desired state, calculates what's need to be created/update/destroy... and then delegates the tasks to providers.
* Set of providers: There https://registry.terraform.io/browse/providers[many providers].
IaaS (this can be cloud providers such as AWS, Azure, GCP or on premise such as Open stack, VM Ware), PaaS (Heroku, Kubernetes, etc.), to SaaS (DataDog, Fastly, Github Teams, etc.)

.Terraform Architecture
image::2021-07-terraform-architecture.png[]

=== Terraform and Azure

Terraform can an infrastructure across multiple cloud providers.
It's just a matter for this cloud provider to provide the right Terraform modules
The https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs[Terraform Azure provider]

.Main Terraform Template
[source,yaml]
----
include::{code-github-url}/terraform/main.tf[tag=adocAzurerm]
----

== What Is NubesGen?

There are several ways to manually deploy a Java application to Azure.
You can use the https://docs.microsoft.com/en-us/cli/azure/install-azure-cli[Azure command line], the https://portal.azure.com/#home[Azure admin console] or the https://github.com/microsoft/azure-maven-plugins[Maven Azure plugin].
But you need to create the infrastructure first (security roles, storage, configure the DNS, etc.).
That's when Terraform can be handy.

But as we've just seen, depending on the complexity of your infrastructure, writing Terraform configuration files can be a bit tricky.
That's when NubesGen came become very handy:
we can use NubesGen to generate the Terraform files.

https://nubesgen.com/[NubesGen] is an open source project that was initiated in 2021.
It lets you generate Terraform templates either using a web interface or curl commands.
For example, if you want to generate Terraform templates for a Quarkus application, you can go to https://xxx[www] and choose Quarkus from the combobox.

You can also specify the region, if the application needs a database, a Redis cache or...
This will download a zip file containing the generated templates that you can add to your project.

If, like me, you prefer the command line, NubesGen allows you to download these template throught a curl command.
Downloading throught the Web interface or the command line results in the same templates.

Let's see NubesGen in action.

== Generating a Simple Quarkus Application

First of all, let's generate a simple Quarkus application.
This application exposes a RestEndpoint that says "Hello NubesGen".
Nothing too fancy, but this allows us to focus on the deployment, not the code.

=== Bootstrapping a Quarkus Application

Go to https://xxx[code.quarkus.io], specify your project name, group and artifact id, and select the Rest Easy extension.
Download the Zip file.
This is what you should have:

.Maven command to bootstrap a Quarkus application
[source,bash]
----
include::{code-github-url}/bootstrap.sh[tag=adocSnippet]
----

Now, to execute it, type `mvn quarkus:dev`.
Once Quarkus is up and ready, invoke the endpoint pointing at the URL ``.

=== Updating the Generated Code

.Rest Endpoint
[source,java]
----
include::{code-github-url}/src/main/java/org/agoncal/article/nubesgen/terraform/GreetingResource.java[tag=adocSnippet]
----

.Testing the Rest Endpoint
[source,java]
----
include::{code-github-url}/src/test/java/org/agoncal/article/nubesgen/terraform/GreetingResourceTest.java[tag=adocSnippet]
----

=== Packaging the Application

We've just executed Quarkus in development mode.
What we need now is to package the application.
Quarkus has different ways of packaging an application:
as a Docker image, a native binary (thanks to GraalVM) or as an executable JAR.
Let's go for this option now, it's simple and portable.

To get a Uber-JAR of the application, execute the following command:

[source,bash]
----
$ mvn package -Dquarkus.package.type=uber-jar
----

As an alternative, you can set the property in the `application.properties` so you don't have to pass it to the command line:

[source,properties]
----
quarkus.package.type=uber-jar
----

Then, it's just a matter of executing `mvn package`  and you will get an Uber JAR:

[source,bash]
----
$ mvn package
----

In the `target` directory you end up with two JAR files.
The `.jar.original` file is the one that is automatically packaged by Maven and is not executable (it's just a JAR file with our code).
The other one (`-runner.jar`) is 12 MB and is executable.
That's the one we want to deploy.

[source,bash]
----
$ ll target/

-rw-r--r--   12M  quarkus-nubesgen-terraform-1.0.0-SNAPSHOT-runner.jar
-rw-r--r--  6.3K  quarkus-nubesgen-terraform-1.0.0-SNAPSHOT.jar.original
----

=== Executing the Application

To run the application is just a matter of executing:

[source,bash]
----
$ java -jar target/quarkus-nubesgen-terraform-1.0.0-SNAPSHOT-runner.jar
----

[source,bash]
----
$ curl http://localhost:8080/hello

Hello NubesGen 2021-07-07T14:21:54.314396Z
----

== Generating the Terraform Templates with NubesGen

We have a simple application, with no database, no authentication, nothing, packaged in an executable Uber-JAR.
Let's ask NubesGen to generate the Terraform templates.

=== Generating with the Web Application

Click on download.

.Generating with NubesGen Web App
image::2021-07-nubesgen.png[]

=== Generating with a cURL Command

.cURL Command Generating Templates
[source,bash]
----
$ curl "https://nubesgen.com/quarkus-nubesgen-terraform.tgz?region=northeurope&application=APP_SERVICE.free&runtime=QUARKUS&database=NONE.free" | tar -xzvf -
----

=== Generated Files

.Generated Terraform Templates
image::2021-07-terraform-files.png[]

=== Main Terraform Template

.Declares the Azure Provider
[source,yaml]
----
include::{code-github-url}/terraform/main.tf[tag=adocAzurerm]
----

.Includes Application Templates
[source,yaml]
----
include::{code-github-url}/terraform/main.tf[tag=adocAzureApplication]
----

.Defines Variables
[source,yaml]
----
include::{code-github-url}/terraform/variables.tf[tag=adocAzureAppName]
----

=== Application Terraform Template

.Defines the Application
[source,yaml]
----
include::{code-github-url}/terraform/modules/app-service/main.tf[tag=adocServiceDef]
----

== Executing the Terraform Templates

=== Initalizing the Templates

.Initialize
[source,bash]
----
terraform$ terraform validate

│ Error: Module not installed
│
│   module "application" {
│
│ This module is not yet installed. Run "terraform init" to install all modules required by this configuration.
----

In fact, no other Terraform command will work without initialization.

.Initialize
[source,bash]
----
terraform$ terraform init

Initializing modules...
- application in modules/app-service

Initializing the backend...

Initializing provider plugins...
- Finding hashicorp/azurerm versions matching ">= 2.56.0"...
- Installing hashicorp/azurerm v2.66.0...
- Installed hashicorp/azurerm v2.66.0 (signed by HashiCorp)

Terraform has been successfully initialized!
----

At that moment, Terraform creates a `.terraform` directory with generated files, such as the `modules.json` or `.terraform.lock.hcl` files, but it also download the needed module (here the GO executable `terraform-provider-azurerm_v2.66.0_x5`).

.Generated Temporary Files
image::2021-07-terraform-init.png[]

.Initialize
[source,bash]
----
terraform$ terraform validate
Success! The configuration is valid.

terraform$ terraform show
No state.
----

=== Showing the Visual Representation of the Execution Plan

https://www.terraform.io/docs/cli/commands/graph.html

If you have https://graphviz.org[GraphViz] installed, you can even generate a visual representation of either a configuration or execution plan.
.Initialize
[source,bash]
----
terraform$ terraform graph
terraform$ terraform graph | dot -Tpng > graph.png
----

image::2021-07-terraform-graph.png[]

=== Logging in to Azure

.Planning
[source,bash]
----
terraform$ terraform plan

│ Error: Error building AzureRM Client: obtain subscription() from Azure CLI: Error parsing json result from the Azure CLI: Error waiting for the Azure CLI: exit status 1: ERROR: Please run 'az login' to setup account.
----

.Planning
[source,bash]
----
terraform$ az login
You have logged in.

terraform$ az account show

{
  "environmentName": "AzureCloud",
  "homeTenantId": "1234-abcd",
  "id": "abcd-1234",
  "isDefault": true,
  "managedByTenants": [],
  "state": "Enabled",
  "tenantId": "1234-abcd",
  "user": {
    "name": "my.email@gmail.com",
    "type": "user"
  }
}
----

=== Planning the Execution

.Planning
[source,bash]
----
terraform$ terraform plan

Terraform will perform the following actions:

  # azurerm_resource_group.main will be created
  # module.application.azurerm_app_service.application will be created
  # module.application.azurerm_app_service_plan.application will be created

Plan: 3 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + application_hostname = (known after apply)
  + resource_group       = "rg-quarkus-nubesgen-terraform-001"
----

=== Applying the Execution Plan

.Initialize
[source,bash]
----
terraform$ terraform apply

azurerm_resource_group.main: Creating...
azurerm_resource_group.main: Creation complete after 0s [id=/subscriptions/1234-abcd/resourceGroups/rg-quarkus-nubesgen-terraform-001]
module.application.azurerm_app_service_plan.application: Creating...
module.application.azurerm_app_service_plan.application: Creation complete after 19s [id=/subscriptions/1234-abcd/resourceGroups/rg-quarkus-nubesgen-terraform-001/providers/Microsoft.Web/serverfarms/plan-quarkus-nubesgen-terraform-001]
module.application.azurerm_app_service.application: Creating...
module.application.azurerm_app_service.application: Creation complete after 30s [id=/subscriptions/1234-abcd/resourceGroups/rg-quarkus-nubesgen-terraform-001/providers/Microsoft.Web/sites/app-quarkus-nubesgen-terraform-001]

Apply complete! Resources: 3 added, 0 changed, 0 destroyed.

Outputs:

application_hostname = "https://app-quarkus-nubesgen-terraform-001.azurewebsites.net"
resource_group = "rg-quarkus-nubesgen-terraform-001"
----

On the other hand, if Terraform finds out that the infrastructure was already created and does not need to be updated, then you will get a message such as:

.Planning
[source,bash]
----
No changes. Your infrastructure matches the configuration.

Terraform has compared your real infrastructure against your configuration and found no differences, so no changes are needed.

Apply complete! Resources: 0 added, 0 changed, 0 destroyed.

Outputs:

application_hostname = "https://app-quarkus-nubesgen-terraform-001.azurewebsites.net"
resource_group = "rg-quarkus-nubesgen-terraform-001"
----

[source,bash]
----
$ open https://app-quarkus-nubesgen-terraform-001.azurewebsites.net
----

.No Web App Deployed
image::2021-07-azure-no-webapp.png[]

=== Deploying the Uber JAR

[source,bash]
----
$ mvn com.microsoft.azure:azure-webapp-maven-plugin:2.0.0:config

Auth type: AZURE_CLI
Default subscription: (1234-abcd)
Username: my.email@gmail.com

Java SE Web Apps in subscription:
* 1: <create>
  2: app-quarkus-nubesgen-terraform-001 (Linux|Java 11|Java SE)

Please confirm webapp properties
Subscription Id : 1234-abcd
AppName : app-quarkus-nubesgen-terraform-001
ResourceGroup : rg-quarkus-nubesgen-terraform-001
Region : northeurope
PricingTier : F1
OS : Linux
Java : Java 11
Web server stack: Java SE
Deploy to slot : false
Confirm (Y/N) [Y]:
----

[source,xml]
----
<plugin>
  <groupId>com.microsoft.azure</groupId>
  <artifactId>azure-webapp-maven-plugin</artifactId>
  <version>2.0.0</version>
  <configuration>
    <schemaVersion>v2</schemaVersion>
    <subscriptionId>1234-abcd</subscriptionId>
    <resourceGroup>rg-quarkus-nubesgen-terraform-001</resourceGroup>
    <appName>app-quarkus-nubesgen-terraform-001</appName>
    <pricingTier>F1</pricingTier>
    <region>northeurope</region>
    <appServicePlanName>plan-quarkus-nubesgen-terraform-001</appServicePlanName>
    <appServicePlanResourceGroup>rg-quarkus-nubesgen-terraform-001</appServicePlanResourceGroup>
    <runtime>
      <os>Linux</os>
      <javaVersion>Java 11</javaVersion>
      <webContainer>Java SE</webContainer>
    </runtime>
    <deployment>
      <resources>
        <resource>
          <directory>${project.basedir}/target</directory>
          <includes>
            <include>*.jar</include>
          </includes>
        </resource>
      </resources>
    </deployment>
  </configuration>
</plugin>
----

[source,bash]
----
$ mvn azure-webapp:deploy

Auth type: AZURE_CLI
Default subscription: (1234-abcd)
Username: my.email@gmail.com
[INFO] Updating target Web App app-quarkus-nubesgen-terraform-001...
[INFO] Successfully updated Web App app-quarkus-nubesgen-terraform-001.
[INFO] Trying to deploy artifact to app-quarkus-nubesgen-terraform-001...
[INFO] Deploying (target/quarkus-nubesgen-terraform-1.0.0-SNAPSHOT-runner.jar)[jar]  ...
[INFO] Successfully deployed the artifact to https://app-quarkus-nubesgen-terraform-001.azurewebsites.net
----

== Checking the Application on Azure

[source,bash]
----
$ curl https://app-quarkus-nubesgen-terraform-001.azurewebsites.net/hello
----

=== Checking with the Azure Console

=== Checking with the Azure CLI

.Initialize
[source,bash]
----
$ az webapp list -g rg-quarkus-nubesgen-terraform-001
----

=== Redeploying a New Version of the Application

Now that the infrastructure is setup, that the Maven Azure plugin is configured, if you need to re deploy a new version of the application, it's quite easy.
Change the code and then

[source,bash]
----
$ mvn package

$ mvn azure-webapp:deploy

$ curl https://app-quarkus-nubesgen-terraform-001.azurewebsites.net/hello
----

== Conclusion

Terraform can be tricky.
Its language is simple, but because Terraforma has an extension mecanism, its ecosystem is huge.
You can find extension for Java, for AWS, for GCP... and for Azure.
Deploying to the cloud, even a simple application, can take you a few lines of code to write.

But this is not the workflow we would like.
I don't know about you, but I would love to a CI/CD environment that would build my application and deploy it automatically to Azure.
Using GitHub Actions maybe.
But again, that's new GitHub Actions templates to be created and I don't have the knowledge.
Wait, maybe NubesGen can help?

== References

* https://www.terraform.io/intro/index.html[Introduction to Terraform]
* https://www.youtube.com/watch?v=h970ZBgKINg[Introduction to HashiCorp Terraform with Armon Dadgar]
* https://k21academy.com/terraform-iac/terraform-beginners-guide/[Terraform Beginner’s Guide: Everything You Should Know]
* https://docs.microsoft.com/en-us/azure/developer/terraform/overview[Terraform with Azure]
* https://github.com/terraform-providers/terraform-provider-azurerm[Terraform Provider for Azure (Resource Manager) on GitHub]
* https://docs.microsoft.com/en-us/azure/developer/java/eclipse-microprofile/deploy-microprofile-quarkus-java-app-with-maven-plugin[Deploy a Quarkus Web App to Azure App Service with Maven]
* https://nubesgen.com/[NubesGen] and the https://github.com/microsoft/nubesgen[NubesGen GitHub] repository
